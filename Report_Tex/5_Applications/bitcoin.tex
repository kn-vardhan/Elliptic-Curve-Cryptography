\chapter{Applications of ECC} 

\section{Bitcoin}
\textit{This section of the report has been worked upon by Anita Dash and Tata Sai Manoj.}

% https://learn.saylor.org/mod/book/tool/print/index.php?id=36353
% https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch04.asciidoc

\subsection{Introduction}
Bitcoin is a digital currency in which transactions between peers are verified and records of the transactions are maintained by a decentralized system. It uses secure methods in cryptography that does not require a central authority to have access to personal data.  

The ownership of a bitcoin is determined by the wallet of the user. The wallet stores the encryption material that is required to "access" that bitcoin, like the public address. The wallets are made secure with a unique private key that is supposed to ensure that only the user with their own private key can access their wallet. 

Bitcoin works on a digital ledger called the blockchain. The blocks of data are created and introduced into the ledger (which forms a "chain"), hence the name "Blockchain". The process of creating new blocks is typically through a consensus from a majority of verified nodes, which makes the blockchain highly secure against attacks with malicious intent (the attacker should have control of a high number of nodes in order to disrupt the blockchain). 

A bitcoin address is a string of digits and characters that can be shared with anyone who wants to send you money. To convert a bitcoin public key to a bitcoin address, it is first hashed with a "double-hash" function HASH160 (i.e, SHA-256 and RIPEMD160) and then encoded in Base58 with a $0x00$ prefix. 

\subsection{Secp256k1}
%% Reference: https://en.bitcoin.it/wiki/Secp256k1
Bitcoin employs the Elliptic Curve Digital Signature Algorithm to authorise payments by validating ownership during the exchange of cryptocurrency. The elliptic curve used in the algorithm is \textbf{Secp256k1} which is defined by the Standards for Efficient Cryptography Group (SECG).\\
The curve is defined by the equation
\[y^3 = x^2 + 7\]
over the field $\mathbb{F}_p$, where 
\[p = = 2^{256} − 2^{32} − 2^9 − 2^8 − 2^7 − 2^6 − 2^4 − 1\]



%% Reference for below three subsections: https://lewismcombes.github.io/downloads/research/mathematics_of_bitcoin_ecdsa_lmc.pdf
\subsection{Secp256k1 vs Pollard's Rho Algorithm}
We know that the time complexity of Pollard's Rho Algorithm is approximately $O(\sqrt{N})$. The default key length is 256 bits for secp256k1, which implies the time complexity in terms of input size in bits is around $O(2^{128})$. This might require a significant amount of resources and yet still might be infeasible.\\
Pollard's rho method with automorphism is a modified algorithm of Pollard Rho to speed up the time complexity $^{\cite{a8}}$. % reference: https://blog.coinfabrik.com/wp-content/uploads/2016/06/ECDSA-Security-in-Bitcoin-and-Ethereum-a-Research-Survey.pdf
The key idea of the method is to find a function that runs over the equivalence
classes on the automorhpism groups generated by an automorphism $\alpha: E(\mathbb{F}_p) \rightarrow E(\mathbb{F}_p)$ rather than the points and replace it in the Pollard’s Rho algorithm.\\
However this method only speeds up the algorithm by a factor and thus secp256k1 is safe against this attack $^{\cite{a8}}$. % reference: https://blog.coinfabrik.com/wp-content/uploads/2016/06/ECDSA-Security-in-Bitcoin-and-Ethereum-a-Research-Survey.pdf

\subsection{Secp256k1 vs Pohlig-Hellman Algorithm}
The Pohlig-Hellman Algorithm reduces the problem of finding a discrete log of a point to finding discrete logs modulo the prime factors of the order of the point $P$. Using this algorithm along with Pollard's Rho can speed up the process to a time complexity equal to the square root of the highest prime factor order of $P$.\\
However the order of the base point in Secp256k1 is a prime number and hence there is no possibility of speeding up the algorithm using Pollard Rho. And hence this attack cannot break security systems.

\subsection{Secp256k1 vs Transfer Methods}
 The key idea of these methods is to reduce efficiently an ECDLP into a discrete logarithm problem in a different group (like $\mathbb{F}^\times_{p^m}$). And then use index calculus to solve the DLP in sub-exponential time. Methods such as MOV Attack, Frey Ruck Attack are consider as transfer methods $^{\cite{a8}}$.\\ %reference: % reference: https://blog.coinfabrik.com/wp-content/uploads/2016/06/ECDSA-Security-in-Bitcoin-and-Ethereum-a-Research-Survey.pdf
However to carry out a transfer attack attack against Secp256k1, one would have
to work in a field of size approximately ${10^{10}}^{78}$ % reference: https://lewismcombes.github.io/downloads/research/mathematics_of_bitcoin_ecdsa_lmc.pdf
which is somewhat infeasible $^{\cite{a9}}$. Thus Secp2651 is safe against transfer attacks

\section{Attacks on ECDSA}

% http://koclab.cs.ucsb.edu/teaching/ecc/project/2015Projects/Schmid.pdf
% https://bitcoin.org/en/alert/2013-08-11-android

\subsection{PlayStation3 Console}
\indent The PlayStation 3 is a video game console developed by Sony. In the annual Chaos Communication Congress conference held in 2010 at Berliner Congress Center in Germany, a hacker group named \textbf{fail0verflow} presented a flaw in the ECDSA algorithm used by Sony. 

They were able to deduce the private key used within the ECDSA, which meant that pirated and unlicensed games could be signed as ``official" Sony software.  The flaw in the implementation was using a pseudo-random number generator which led to different signatures being 

Let $(x_1, S_1)$ and $(x_2, S_2)$ be two digital signatures on two different messages $M_1$ and $M_2$ using the same random number $m$. 

$Q = mP$, and $x_1 = x_2 = x_Q$ since $m$ is fixed. 
Let $z_1$ and $z_2$ be the $L_n$ left most bits of the hashed message. 
\begin{align*} 
&S_1 \equiv m^{-1} z_1 (mod \,\, m) \quad S_2 \equiv m^{-1} z_2 (mod \,\, m) \\
&S_1 - S_2 \equiv m^{-1} (z_1 - z_2) (mod \,\, m) \\
& m \equiv (z_1 - z_2)(S_1 - S_2)^{-1} (mod \,\, m)
\end{align*}
So, the value of $m$ is obtained, which leads to the value of private key as follows. 
\begin{align*}
    &S_2 \equiv m^{-1} (z_2 + x_2 l) (mod \,\, m) \\
    &l \equiv {x_2}^{-1} (m S_2 - z_2) (mod \,\, m) 
\end{align*}
\subsection{Bitcoin Android Security Vulnerability}
Another example of a flawed implementation of ECDSA happened in the case of Bitcoin. The flaw was very similar to the case of Sony PlayStation, where the Android Java SecureRandom(\,) function produced numbers that are deterministic. With a similar proof as above, the attacker can obtain the private key of the person who made the transaction, and then perform transactions impersonating that person. This vulnerability led to the theft of at least $55$ \textbf{BTC}. 

\section{Twist Attack on Secp256k1}
%% Reference https://github.com/christianlundkvist/blog/blob/master/2020_05_26_secp256k1_twist_attacks/secp256k1_twist_attacks.md
If a victim has a \textit{Naive Implementation} of certain functions, The attacker can take advantage of this and trick the victim into revealing information about their private key. We will discuss how this is possible in detail below

\subsection{Small Sub-Group Attack}
Let the elliptic curve $E$ have a subgroup $H$ with a few elements compared to the order of $E$ such that the point $T$ on $E$ generates $H$. we know that the addition operation on the elliptic curve defines a group structure on the points of an elliptic curve. Let the order of $H$ be a prime $q$. \\
An attacker can choose a point $P$ from subgroup $H$, send it to the victim as their public key and ask them to encrypt a message using their private key $b$. Once the victim calculates $Q = bP$ and encrypts the message using $Q$, the attacker can brute force by checking every element in $H$ , and find $yP \in H$ such that $y \equiv b \pmod{q}$.\\
This way the attacker can get some information on the victim's private key.\\
If the attacker repeats the same method for a number of different subgroups whose product of orders is larger than $2^{256}$, then by using Chinese Remainder Theorem the attacker can find the victim's private key.
\[b < 2^{256} \quad therefore, \quad y' \equiv b \pmod{p'>2^{256}} \implies y' = b\]
\newpage 

\subsection{Twist Attack on Secp256k1}
Bitcoin uses the elliptic curve Secp256k1, whose order is a prime number. \\ 
By Lagrange's Theorem, we know that there can be no non trivial subgroups to this group.\\
However based on the Group Law $\ref{Group_Law}$, we can see that the addition and multiplication of points do not use the constant term $B$ of the curve. Therefore the attacker can pick a point $P$ from a curve that differs from Secp256k1 by a constant (also has multiple smaller subgroups) and send it to the victim. \\ 
If the victim's function that calculates addition and multiplication does not verify whether the point lies on Secp256k1, then their software will perform the calculations on the curve chosen by the attacker, and the attacker can brute force to find the victim's private key.\\
The attacker can find the victim's private key by slightly modifying the small subgroup attack, below we show the algorithm.

\subsection{Algorithm}
\begin{algorithm}
    \caption{Twist attack on Secp256k1 curve}
    \begin{algorithmic}[1]
    \Procedure{Twist-Attack}{}
    \State \textbf{\underline{Input}:} Prime $p = 2^{256} - 2^{32} - 977$, Private Key b, Secp256k1 curve E 
    \State \textbf{\underline{Output}:} Private key of Bob 
    \State Consider similar elliptic curves to $E$ (namely $E_1, E_2, \cdots, E_n$) that differ by a constant term. 
    \State Factorize the number of points and pick subgroups of relatively small size from each elliptic curve $\left(P_{11}, P_{12}, \cdots, P_{1 k_1}, P_{21}, P_{22}, \cdots, P_{2 k_2}, \cdots, P_{n 1}, \cdots, P_{n k_n} \right)$ and product of all sizes of the curve should be greater than $2^{256}$. 
    \State For each of the subgroups, compute the generator points. 
    \State If all of these points are sent to Bob, with a naive implementation of cryptography that does not verify if the point lies on the curve, the reply received will be $\left(Q_{11}, Q_{12}, \cdots, Q_{1 k_1}, Q_{21}, Q_{22}, \cdots, Q_{2 k_2}, \cdots, Q_{n 1}, \cdots, Q_{n k_n} \right)$
    \State Using the Pollard-Rho algorithm for these small subgroups, we can compute the discrete logarithms for all points received. 
    \State The Chinese Remainder Theorem is used to construct the private key from the discrete logarithms and the subgroup sizes. 
    \EndProcedure
    \end{algorithmic}
\end{algorithm}

\subsection{Time Analysis}
For the following analysis, we are using the same twist curves and subgroups. Recovering the private key from the subgroups and the discrete logarithms is computationally the slowest step, which is highlighted in the table below. All of the computations were done using the software Sagemath 9.0 and the codes can be found here. % add reference 
\begin{center}
\begin{tabular}{ |p{7cm}|p{2cm}||p{2.1cm}| p{3cm}|}
 \hline
 \multicolumn{4}{|c|}{Time Complexity} \\
 \hline
 Private Key (Hex) &  Bit Size & Steps: $7 \,\textendash\, 9$ & Total Runtime\\
 \hline
 $0$x$c3549423$  & 32 & 387 s & 433.2274 s\\
 $0$x$f837bc8c4461ccd7$ & 64 & 765 s & 809.7708 s\\  
 $0$x$6a9d9fd679c147a78cbc6857dec02e76$ & 128 & 877 s & 925.3762 s \\
 \hline
\end{tabular}
\end{center}

\section{Conclusion}
Mathematically Secp2561 is a good choice for ECC. it is safe and can resist numerous possible attacks like Pollard-Rho, Modified Pollard-Rho and even transfer attacks like MOV attacks are infeasible. However, due to implementation flaws, the security system may be vulnerable to specific attacks like the twist attack. 

